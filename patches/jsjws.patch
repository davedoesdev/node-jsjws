diff --git a/jws-2.0.js b/jws-2.0.js
index cc0561e..49b55bb 100755
--- a/jws-2.0.js
+++ b/jws-2.0.js
@@ -23,6 +23,45 @@
  * @license <a href="http://kjur.github.io/jsjws/license/">MIT License</a>
  */
 
+var hmac;
+if (typeof require === 'function')
+{
+    var crypto = require('crypto');
+    hmac = function (alg, key, data)
+    {
+        var mac = crypto.createHmac(alg, key);
+        mac.update(data);
+        return mac.digest('base64');
+    };
+}
+else
+{
+    hmac = function (alg, key, data)
+    {
+        var mac = new KJUR.crypto.Mac({alg: 'hmac' + alg, pass: key});
+        mac.updateString(data);
+        return hex2b64(mac.doFinal());
+    };
+}
+// from https://github.com/goinstant/buffer-equal-constant-time/blob/master/index.js
+// NOTE: keep an eye out for built-in constant time comparison function in Node:
+// https://github.com/joyent/node/issues/8560
+var const_time_equal = function (s1, s2)
+{
+    "use strict";
+    if (s1.length !== s2.length)
+    {
+        return false;
+    }
+    var i, c = 0;
+    for (i = 0; i < s1.length; i += 1)
+    {
+        /*jslint bitwise: true */
+        c |= s1.charCodeAt(i) ^ s2.charCodeAt(i); // XOR
+        /*jslint bitwise: false */
+    }
+    return c === 0;
+};
 if (typeof KJUR == "undefined" || !KJUR) KJUR = {};
 if (typeof KJUR.jws == "undefined" || !KJUR.jws) KJUR.jws = {};
 
@@ -105,7 +144,7 @@ KJUR.jws.JWS = function() {
      * @throws if sJWS is not comma separated string such like "Header.Payload.Signature".
      */
     this.getEncodedSignatureValueFromJWS = function(sJWS) {
-	if (sJWS.match(/^[^.]+\.[^.]+\.([^.]+)$/) == null) {
+	if (sJWS.match(/^[^.]+\.[^.]+\.([^.]*)$/) == null) {
 	    throw "JWS signature is not a form of 'Head.Payload.SigValue'.";
 	}
 	return RegExp.$1;
@@ -126,7 +165,7 @@ KJUR.jws.JWS = function() {
 	    (sigValNotNeeded || (this.parsedJWS.sigvalH !== undefined))) {
 	    return;
 	}
-	if (sJWS.match(/^([^.]+)\.([^.]+)\.([^.]+)$/) == null) {
+	if (sJWS.match(/^([^.]+)\.([^.]+)\.([^.]*)$/) == null) {
 	    throw "JWS signature is not a form of 'Head.Payload.SigValue'.";
 	}
 	var b6Head = RegExp.$1;
@@ -202,24 +241,69 @@ KJUR.jws.JWS = function() {
      * @throws if sJWS is not comma separated string such like "Header.Payload.Signature".
      * @throws if JWS Header is a malformed JSON string.
      */
-    this.verifyJWSByKey = function(sJWS, key) {
-	this.parseJWS(sJWS);
-	var hashAlg = _jws_getHashAlgFromParsedHead(this.parsedJWS.headP);
-        var isPSS = this.parsedJWS.headP['alg'].substr(0, 2) == "PS";
+    this.verifyJWSByKey = function(sJWS, key, allowed_algs) {
+	this.parseJWS(sJWS, (!key) || !key.verifyString);
+    var headP = this.parsedJWS.headP;
+    var alg = headP.alg;
+    if (alg === undefined)
+    {
+        throw new Error('alg not present');
+    }
+    allowed_algs = allowed_algs || [];
+    function is_allowed(a)
+    {
+        if (Array.isArray(allowed_algs))
+        {
+            return allowed_algs.indexOf(a) >= 0;
+        }
+        else
+        {
+            return allowed_algs[a] !== undefined;
+        }
+    }
+    if (!is_allowed(alg))
+    {
+        throw new Error('algorithm not allowed: ' + alg);
+    }
+
+    if (alg === 'none')
+    {
+        return true;
+    }
+    if (!key)
+    {
+        if (!is_allowed('none'))
+        {
+            throw new Error('no key but none alg not allowed');
+        }
+        return true;
+    }
+
+    var hashAlg = _jws_getHashAlgFromParsedHead(headP);
+    alg = alg.substr(0, 2);
+    var isPSS = alg === "PS";
+    var r;
 
 	if (key.hashAndVerify) {
-	    return key.hashAndVerify(hashAlg,
-				     new Buffer(this.parsedJWS.si, 'utf8').toString('base64'),
-				     b64utob64(this.parsedJWS.sigvalB64U),
-				     'base64',
+	    r = key.hashAndVerify(hashAlg,
+				     new Buffer(this.parsedJWS.si, 'utf8'),
+				     new Buffer(b64utob64(this.parsedJWS.sigvalB64U), 'base64'),
+				     null,
 				     isPSS);
 	} else if (isPSS) {
-	    return key.verifyStringPSS(this.parsedJWS.si,
+	    r = key.verifyStringPSS(this.parsedJWS.si,
 				       this.parsedJWS.sigvalH, hashAlg);
-	} else {
-	    return key.verifyString(this.parsedJWS.si,
+	} else if (alg === "HS") {
+        r = const_time_equal(hmac(hashAlg, key, this.parsedJWS.si), b64utob64(this.parsedJWS.sigvalB64U));
+    } else {
+	    r = key.verifyString(this.parsedJWS.si,
 				    this.parsedJWS.sigvalH);
 	}
+    if (!r)
+    {
+        throw new Error('failed to verify');
+    }
+    return r;
     };
 
     /**
@@ -243,12 +327,17 @@ KJUR.jws.JWS = function() {
     };
 
     // ==== JWS Generation =========================================================
+    var supported_algos = {
+        RS256: true, RS512: true,
+        PS256: true, PS512: true,
+        HS256: true, HS512: true
+    };
+
     function _jws_getHashAlgFromParsedHead(head) {
-	var sigAlg = head["alg"];
+	var sigAlg = head.alg;
 	var hashAlg = "";
 
-	if (sigAlg != "RS256" && sigAlg != "RS512" &&
-	    sigAlg != "PS256" && sigAlg != "PS512")
+	if (!supported_algos[sigAlg])
 	    throw "JWS signature algorithm not supported: " + sigAlg;
 	if (sigAlg.substr(2) == "256") hashAlg = "sha256";
 	if (sigAlg.substr(2) == "512") hashAlg = "sha512";
@@ -268,21 +357,26 @@ KJUR.jws.JWS = function() {
 	return sigValue;
     };
 
-    function _jws_generateSignatureValueBySI_Key(sHead, sPayload, sSI, key, head) {
-	var hashAlg = null;
-	if (typeof head == "undefined") {
-	    hashAlg = _jws_getHashAlgFromHead(sHead);
-	} else {
-	    hashAlg = _jws_getHashAlgFromParsedHead(head);
-	}
+    function _jws_generateSignatureValueBySI_Key(headP, sPayload, sSI, key) {
+    var alg = headP.alg;
+
+    if (alg === 'none') {
+        return '';
+    }
+
+    var hashAlg = _jws_getHashAlgFromParsedHead(headP);
+
+	alg = alg.substr(0, 2);
 
-	var isPSS = head['alg'].substr(0, 2) == "PS";
+    var isPSS = alg === "PS";
 
 	if (key.hashAndSign) {
-	    return b64tob64u(key.hashAndSign(hashAlg, sSI, 'binary', 'base64', isPSS));
+	    return b64tob64u(key.hashAndSign(hashAlg, sSI, 'utf8', 'base64', isPSS));
 	} else if (isPSS) {
 	    return hextob64u(key.signStringPSS(sSI, hashAlg));
-	} else {
+	} else if (alg === "HS") {
+        return b64tob64u(hmac(hashAlg, key, sSI));
+    } else {
 	    return hextob64u(key.signString(sSI, hashAlg));
 	}
     };
@@ -339,7 +433,7 @@ KJUR.jws.JWS = function() {
 	if (!this.isSafeJSONString(sHead, obj, 'headP'))
 	    throw "JWS Head is not safe JSON string: " + sHead;
 	var sSI = _getSignatureInputByString(sHead, sPayload);
-	var b64SigValue = _jws_generateSignatureValueBySI_Key(sHead, sPayload, sSI, key, obj.headP);
+	var b64SigValue = _jws_generateSignatureValueBySI_Key(obj.headP, sPayload, sSI, key);
 
 	this.parsedJWS = {};
 	this.parsedJWS.headB64U = sSI.split(".")[0];
